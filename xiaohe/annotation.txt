1.元注解 (5种)
@Retention
@Documented
@Target
@Inherited 继承性
@Repeatable 可重复 java8后才被引入

2. SpringBoot 集成redis两种方式
第一种：添加完依赖，可以直接StringRedisTemplate, RedisTemplate可直接注入使用
     <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
     </dependency>
第二种： Redis官方推荐方式Jedis
     <dependency>
        <groupId>redis.clients</groupId>
        <artifactId>jedis</artifactId>
     </dependency>

3. SpringBoot 事务详解
   声明式事务和编程式事务（TransactionTemplate）
   > 事务四个特性：原子性、一致性、隔离性、持久性。
   > 事务隔离级别：
   读未提交的 READ_UNCOMMITTED、
   读已提交的 READ_COMMITTED、(ORACLE数据库默认隔离级别)
   可重复读 REPEATABLE_READ、(MYSQL数据库默认隔离级别)
   可序化 SERIALIZALE。 （隔离级别依次上升）
   DEFAULT ,这是spring默认的隔离级别，表示使用数据库默认的事务隔离级别。另外四个与JDBC的隔离级别相对应。
   注意：事务的隔离级别和数据库并发性是成反比的，隔离级别越高，并发性越低。

   > 脏读、不可重复读、幻读：
   1、脏读
   脏读就是指当A事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，B事务也访问这个数据，然后使用了这个数据。这时候如果事务A回滚，那么B事务读到的数据是不被承认的。
   2、不可重复读（重点在修改，体现在值不同）
   指在A事务内，多次读同一数据。在A事务还没有结束时，B事务也访问该同一数据。那么，在A事务中的两次读数据之间，由于B事务的修改，那么A事务两次读到的的数据可能是不一样的。这样就发生了在A事务内两次读到的数据是不一样的。
   3、幻读（重点在增加或删除，体现在记录数不同）
   是指当事务不是独立执行时发生的一种现象，例如A事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，B事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作A事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。

4. 事务传播行为是针对嵌套事务而言的。 有下列7种
第一种：REQUIRED (Spring 默认事务传播行为)
       支持事务。如果业务方法执行时已经在一个事务中，则加入当前事务，否则新建一个事务。
       外层事务提交了，内层才会提交。
       内/外只要有报错，它两会一起回滚。
  重点：只要内层事务执行错误抛出异常，外层即使有try/catch，该事务也会回滚。
       因为内外层方法在同一个事务当中，内层只要抛出了异常，这个事务就会被设置成rollback-only，即使外层try/catch内层的异常，该事务也会回滚。

第二种：REQUIRES_NEW
       支持事务。每次都是创建一个新的事务，即使当前已经在事务中了，会挂起当前事务。
       内层事务结束，内层就提交了，不用等着外层一起提交。
       外层报错回滚，不影响内层。
       内层报错回滚，外层try/catch内层的异常，外层不会回滚。
  重点：内层报错回滚，然后又会抛出异常，外层如果没有捕获处理内层抛出来的这个异常，外层还是会回滚的。

第三种：NESTED
       支持事务。如果当前已经在一个事务中了，则嵌套在已有的事务中作为一个子事务。如果当前没在事务中则开启一个事务。
       内层事务结束，等着外层事务一起提交。
       外层回滚，内层也一起回滚。
  重点：内层回滚，不影响外层。这个内层回滚不影响外层是有前提条件的， 否则内外都回滚。
       内层必须是在Nested模式下，且外层对内层的异常进行try/catch捕获。

第四种：SUPPORTS
       支持事务。当前有事务就支持。当前没有事务就算了， 不会开启一个事务。
       @Transactional(propagation=Propagation.SUPPORTS)修饰的方法本身是没有事务属性的。
       内层要等外层一起提交。

第五种：MANDATORY
       支持事务。如果业务方法执行时，已经在一个事务中，则加入当前事务，否则抛出异常。
       内层要等外层一起提交。

第六种：NOT_SUPPORTED
       不支持事务。如果业务方法执行时已经在一个事务中，则挂起当前事务，等方法执行完毕后，事务恢复进行。
       内层方法执行完后就提交，不用等外层事务结束。

第七种：NERVER
       不支持事务。如果当前已经在一个事务中了，抛出异常。


























